/**
 * Consolidated API handler for Vercel serverless environment
 * This file handles multiple API routes to stay within Vercel's Hobby plan limits
 * Updated for MongoDB integration with enhanced error handling
 */

// Set serverless environment flag
process.env.VERCEL = '1';

// Import required modules
const serverless = require('serverless-http');
const app = require('../server');

// Create a wrapper function to handle the serverless request
const handler = async (req, res) => {
  console.log(`[${new Date().toISOString()}] Serverless request: ${req.method} ${req.url}`);
  
  try {
    // Set a timeout for the request
    const requestTimeout = setTimeout(() => {
      if (!res.headersSent) {
        console.error(`Request timeout for ${req.url}`);
        res.status(504).json({
          error: 'Gateway Timeout',
          message: 'Request took too long to process',
          path: req.url
        });
      }
    }, 10000); // 10 second timeout
    
    // Process the request with the main app
    await new Promise((resolve, reject) => {
      res.on('finish', () => {
        clearTimeout(requestTimeout);
        resolve();
      });
      
      res.on('error', (error) => {
        clearTimeout(requestTimeout);
        reject(error);
      });
      
      // Pass the request to the main app
      app(req, res, (error) => {
        clearTimeout(requestTimeout);
        if (error) reject(error);
        else resolve();
      });
    });
  } catch (error) {
    console.error('Serverless handler error:', error);
    
    // If headers are already sent, we can't send another response
    if (!res.headersSent) {
      res.status(500).json({
        error: 'Internal Server Error',
        message: 'An unexpected error occurred',
        path: req.url
      });
    }
  }
};

// Enhanced health check with detailed diagnostics
const healthCheck = async (req, res) => {
  const startTime = Date.now();
  console.log(`[${new Date().toISOString()}] Health check requested`);
  
  // Initialize response object
  const response = {
    status: 'unknown',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    nodeVersion: process.version,
    platform: process.platform,
    memoryUsage: process.memoryUsage(),
    checks: {
      mongoConnection: { status: 'pending' },
      mongoPing: { status: 'pending' },
      bcrModel: { status: 'pending' },
      collections: { status: 'pending' }
    },
    serverless: true,
    duration: 0
  };

  try {
    // Check MongoDB connection state
    const connection = mongoose.connection;
    const readyState = connection.readyState;
    const stateName = ['disconnected', 'connected', 'connecting', 'disconnecting'][readyState] || 'unknown';
    
    // Log current connection state
    console.log(`MongoDB connection state: ${stateName} (${readyState})`);
    
    // Only attempt to connect if not already connected
    if (readyState !== 1) { // 1 = connected
      console.log('Attempting to connect to MongoDB...');
      try {
        await connect();
        response.checks.mongoConnection = {
          status: 'ok',
          state: 'connected',
          readyState: 1,
          reconnected: true
        };
      } catch (connectError) {
        console.error('Failed to connect to MongoDB:', connectError);
        response.checks.mongoConnection = {
          status: 'error',
          state: 'connection_failed',
          readyState: readyState,
          error: connectError.message
        };
        throw new Error('Failed to connect to MongoDB');
      }
    } else {
      // Already connected
      response.checks.mongoConnection = {
        status: 'ok',
        state: stateName,
        readyState: readyState
      };
    }

    // Try to ping the database
    try {
      const pingStart = Date.now();
      await mongoose.connection.db.admin().ping();
      response.checks.mongoPing = {
        status: 'ok',
        duration: `${Date.now() - pingStart}ms`
      };
    } catch (pingError) {
      console.error('MongoDB ping failed:', pingError);
      response.checks.mongoPing = {
        status: 'error',
        error: pingError.message,
        code: pingError.code
      };
      throw new Error('MongoDB ping failed');
    }

    // Check BCR model
    try {
      const BCR = require('../models/Bcr');
      const bcrCheck = await BCR.checkConnection();
      response.checks.bcrModel = {
        status: bcrCheck.connected ? 'ok' : 'error',
        ...(bcrCheck.connected ? {} : { error: bcrCheck.error })
      };
    } catch (bcrError) {
      console.error('BCR model check failed:', bcrError);
      response.checks.bcrModel = {
        status: 'error',
        error: bcrError.message
      };
    }

    // List collections
    try {
      const collections = await mongoose.connection.db.listCollections().toArray();
      response.checks.collections = {
        status: 'ok',
        count: collections.length,
        names: collections.map(c => c.name)
      };
    } catch (collectionsError) {
      console.error('Failed to list collections:', collectionsError);
      response.checks.collections = {
        status: 'error',
        error: collectionsError.message
      };
    }

    // Determine overall status
    const allChecks = Object.values(response.checks);
    const failedChecks = allChecks.filter(check => check.status === 'error');
    
    if (failedChecks.length === 0) {
      response.status = 'up';
    } else {
      response.status = 'degraded';
      response.failedChecks = failedChecks.length;
    }

  } catch (error) {
    console.error('Health check failed:', error);
    response.status = 'down';
    response.error = {
      message: error.message,
      ...(process.env.NODE_ENV === 'development' && { stack: error.stack })
    };
  } finally {
    // Calculate total duration
    response.duration = `${Date.now() - startTime}ms`;
    
    // Set cache headers
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
    
    // Send response
    const statusCode = response.status === 'up' ? 200 : response.status === 'degraded' ? 206 : 503;
    res.status(statusCode).json(response);
    
    console.log(`Health check completed in ${response.duration} with status: ${response.status}`);
  }
};

// Hello endpoint
const hello = async (req, res) => {
  console.log(`[${new Date().toISOString()}] Hello endpoint called`);
  // Check MongoDB connection
  let mongoStatus = 'Not connected';
  let dbState = 'Unknown';
  
  try {
    // Ensure MongoDB is connected
    if (mongoose.connection.readyState !== 1) {
      await connect();
    }
    
    mongoStatus = 'Connected';
    dbState = ['Disconnected', 'Connected', 'Connecting', 'Disconnecting'][mongoose.connection.readyState];
  } catch (error) {
    console.error('[Hello] MongoDB connection error:', error);
    mongoStatus = 'Error';
    dbState = error.message;
  }
  
  res.status(200).json({
    message: 'Hello from RRDM API!',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'production',
    mongodb: {
      status: mongoStatus,
      state: dbState,
      readyState: mongoose.connection.readyState
    },
    serverless: true
  });
};

// Export the handler function for Vercel
module.exports = async (req, res) => {
  console.log(`[Vercel Consolidated] Request received: ${req.method} ${req.url}`);
  
  // Set environment variables for serverless environment
  process.env.VERCEL = '1';
  
  // Handle specific API routes to reduce the number of serverless functions
  if (req.url === '/api/health' || req.url === '/_vercel/health') {
    return healthCheck(req, res);
  }
  
  if (req.url === '/api/hello') {
    return hello(req, res);
  }
  
        // Direct API route handling instead of using Express app
  try {
    // Check if it's one of our simplified API routes
    if (req.url === '/api/test') {
      console.log('[Vercel Consolidated] Direct handling /api/test');
      return res.status(200).json({
        status: 'success',
        message: 'API is working - direct consolidated handler',
        timestamp: new Date().toISOString(),
        method: req.method,
        url: req.url
      });
    }
    
    if (req.url === '/api/bcr/simple-stats') {
      console.log('[Vercel Consolidated] Direct handling /api/bcr/simple-stats');
      return res.status(200).json({
        status: 'success',
        message: 'Direct handling BCR simple stats',
        dbStatus: {
          readyState: mongoose.connection.readyState,
          host: mongoose.connection.host || 'not connected',
          name: mongoose.connection.name || 'not connected'
        },
        environment: process.env.NODE_ENV,
        timestamp: new Date().toISOString()
      });
    }
    
    if (req.url === '/api/bcr/counters') {
      const requestId = Date.now().toString(36);
      const startTime = Date.now();
      console.log(`[${requestId}] [Vercel Consolidated] Direct handling /api/bcr/counters`);
      
      try {
        // Ensure we have a database connection
        if (mongoose.connection.readyState !== 1) {
          console.log(`[${requestId}] MongoDB not connected, connecting now...`);
          await connect();
        }
        
        // Set a timeout for database operations
        const dbTimeout = setTimeout(() => {
          if (!res.headersSent) {
            console.error(`[${requestId}] Database operation timeout`);
            res.status(200).json({
              status: 'partial',
              data: {
                counts: { total: 0, pending: 0, approved: 0, rejected: 0, implemented: 0 },
                byStatus: {},
                byPhase: {}
              },
              meta: {
                requestId,
                timestamp: new Date().toISOString(),
                message: "Database operation timeout - using fallback data",
                duration: Date.now() - startTime
              }
            });
          }
        }, 5000); // 5 second timeout
        
        // Get the Bcr model - direct import to avoid potential issues
        const Bcr = mongoose.models.Bcr || require('../models/Bcr');
        
        // Use a simpler aggregation query
        const [totalCount, statusCounts, phaseCounts] = await Promise.all([
          // Total count with timeout protection
          Bcr.countDocuments({}).exec().catch(() => 0),
          
          // Count by status with timeout protection
          Bcr.aggregate([
            { $group: { _id: '$status', count: { $sum: 1 } } },
            { $project: { _id: 0, status: '$_id', count: 1 } },
            { $maxTimeMS: 2000 } // Apply maxTimeMS correctly as an aggregation stage
          ]).exec().catch(() => []),
          
          // Count by phase with timeout protection
          Bcr.aggregate([
            { $group: { _id: '$phase', count: { $sum: 1 } } },
            { $project: { _id: 0, phase: '$_id', count: 1 } },
            { $maxTimeMS: 2000 } // Apply maxTimeMS correctly as an aggregation stage
          ]).exec().catch(() => [])
        ]);
        
        // Cancel the timeout since we got data
        clearTimeout(dbTimeout);
        
        // Calculate specific status counts
        const pendingCount = statusCounts.find(item => item.status === 'pending')?.count || 0;
        const approvedCount = statusCounts.find(item => item.status === 'approved')?.count || 0;
        const rejectedCount = statusCounts.find(item => item.status === 'rejected')?.count || 0;
        const implementedCount = statusCounts.find(item => item.status === 'implemented')?.count || 0;
        
        // Format the response with actual data
        return res.status(200).json({
          status: 'success',
          data: {
            counts: {
              total: totalCount || 0,
              pending: pendingCount,
              approved: approvedCount,
              rejected: rejectedCount,
              implemented: implementedCount
            },
            byStatus: statusCounts.reduce((acc, { status, count }) => {
              if (status) acc[status] = count;
              return acc;
            }, {}),
            byPhase: phaseCounts.reduce((acc, { phase, count }) => {
              if (phase) acc[phase] = count;
              return acc;
            }, {})
          },
          meta: {
            requestId,
            timestamp: new Date().toISOString(),
            duration: Date.now() - startTime
          }
        });
      } catch (error) {
        console.error(`[${requestId}] Error fetching BCR counters:`, error);
        
        // Return a 200 with partial data instead of 500 to ensure the client gets something
        return res.status(200).json({
          status: 'error',
          data: {
            counts: { total: 0, pending: 0, approved: 0, rejected: 0, implemented: 0 },
            byStatus: {},
            byPhase: {}
          },
          meta: {
            requestId,
            timestamp: new Date().toISOString(),
            error: process.env.NODE_ENV === 'development' ? error.message : 'Database error',
            duration: Date.now() - startTime
          }
        });
      }
    }
    
    // For all other routes, try to use Express but with a timeout that varies by route
    console.log('[Vercel Consolidated] Falling back to Express app for', req.url);
    
    // Set different timeouts based on the requested route
    let timeoutDuration = 5000; // Default 5 second timeout
    
    // Give the dashboard page more time to load
    if (req.url.includes('/bcr/dashboard')) {
      console.log('[Vercel Consolidated] Dashboard page detected, extending timeout');
      timeoutDuration = 20000; // 20 seconds for dashboard
    } else if (req.url.includes('/api/')) {
      timeoutDuration = 10000; // 10 seconds for API endpoints
    }
    
    // Set a timeout for the request
    const requestTimeout = setTimeout(() => {
      if (!res.headersSent) {
        console.error(`[Vercel Consolidated] Request timeout for ${req.url} after ${timeoutDuration}ms`);
        res.status(504).json({
          status: 'error',
          message: 'Request timed out',
          path: req.url,
          timestamp: new Date().toISOString()
        });
      }
    }, timeoutDuration);
    
    // Handle the request with Express
    app(req, res, () => {
      clearTimeout(requestTimeout);
    });
  } catch (error) {
    console.error('[Vercel Consolidated] Error handling request:', error);
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'An unexpected error occurred while processing your request.',
      path: req.url,
      mongodb: {
        readyState: mongoose.connection.readyState,
        error: error.message
      },
      serverless: true
    });
  }
};

module.exports.app = app;
