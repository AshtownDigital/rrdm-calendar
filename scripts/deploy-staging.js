#!/usr/bin/env node

/**
 * RRDM Staging Deployment Script
 * 
 * This script handles the deployment of the RRDM application to the staging environment.
 * It prepares the application by:
 * 1. Switching to the staging environment
 * 2. Testing the MongoDB connection
 * 3. Committing and pushing changes to the staging branch
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const mongoose = require('mongoose');
const dotenv = require('dotenv');

// Configuration
const ROOT_DIR = path.resolve(__dirname, '..');
const STAGING_ENV_FILE = path.join(ROOT_DIR, '.env.staging');

/**
 * Main deployment function
 */
async function deployToStaging() {
  try {
    console.log('üöÄ Starting RRDM Staging Deployment');
    console.log('==================================');
    
    // Step 1: Switch to staging environment
    console.log('\nüìå Step 1: Switching to staging environment');
    await switchToStaging();
    
    // Step 2: Test MongoDB connection
    console.log('\nüìå Step 2: Testing MongoDB connection');
    const connectionSuccess = await testMongoDBConnection();
    if (!connectionSuccess) {
      throw new Error('MongoDB connection test failed. Aborting deployment.');
    }
    
    // Step 3: Build the application
    console.log('\nüìå Step 3: Building the application');
    buildApplication();
    
    console.log('\n‚úÖ RRDM Staging Deployment completed successfully!');
    console.log('\nThe application is now configured for the staging environment.');
    console.log('To start the application, run:');
    console.log('npm run staging');
    
  } catch (error) {
    console.error('\n‚ùå Deployment failed:', error.message);
    process.exit(1);
  }
}

/**
 * Switch to staging environment
 */
async function switchToStaging() {
  try {
    // Check if staging environment file exists
    if (!fs.existsSync(STAGING_ENV_FILE)) {
      throw new Error(`.env.staging file not found. Please create it with the staging configuration.`);
    }
    
    // Update .env file to point to staging
    const envContent = `# This file is auto-generated by deploy-staging.js
# It points to the staging environment
NODE_ENV=staging
`;
    
    fs.writeFileSync(path.join(ROOT_DIR, '.env'), envContent);
    console.log('‚úÖ Switched to staging environment');
    
    return true;
  } catch (error) {
    throw new Error(`Failed to switch to staging environment: ${error.message}`);
  }
}

/**
 * Test MongoDB connection
 */
async function testMongoDBConnection() {
  try {
    // Load environment configuration
    const envConfig = dotenv.parse(fs.readFileSync(STAGING_ENV_FILE));
    Object.keys(envConfig).forEach(key => {
      process.env[key] = envConfig[key];
    });
    
    // Get MongoDB URI from environment
    const mongoUri = process.env.MONGODB_URI;
    if (!mongoUri) {
      throw new Error('MONGODB_URI not found in staging environment configuration');
    }
    
    // Test connection
    console.log('Testing MongoDB connection for staging environment...');
    await mongoose.connect(mongoUri, {
      serverSelectionTimeoutMS: 10000 // 10 second timeout
    });
    console.log('‚úÖ MongoDB connection successful');
    
    // Disconnect
    await mongoose.disconnect();
    return true;
  } catch (error) {
    console.error('‚ùå MongoDB connection failed:', error.message);
    return false;
  }
}

/**
 * Build the application
 */
function buildApplication() {
  try {
    console.log('üî® Building application for staging');
    
    // Install dependencies
    console.log('üì¶ Installing dependencies');
    execSync('npm install', { stdio: 'inherit', cwd: ROOT_DIR });
    
    console.log('‚úÖ Application built successfully');
    return true;
  } catch (error) {
    throw new Error(`Failed to build application: ${error.message}`);
  }
}

// Run the deployment
deployToStaging().catch(console.error);
