#!/usr/bin/env node
/**
 * RRDM Environment Switcher
 * 
 * This script helps switch between different environments (development, staging, production)
 * and ensures the application is properly configured for each environment.
 */
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { PrismaClient } = require('@prisma/client');
const readline = require('readline');

// Create readline interface for user input
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Available environments
const ENVIRONMENTS = ['development', 'staging', 'production'];

// Root directory
const ROOT_DIR = path.resolve(__dirname, '..');

// Function to prompt user for input
function prompt(question) {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer);
    });
  });
}

// Function to check if environment file exists
function checkEnvFile(environment) {
  const envFile = path.join(ROOT_DIR, `.env.${environment}`);
  return fs.existsSync(envFile);
}

// Function to validate database connection
async function testDatabaseConnection(environment) {
  try {
    // Set environment variable temporarily
    process.env.NODE_ENV = environment;
    
    // Load environment configuration
    const envFile = path.join(ROOT_DIR, `.env.${environment}`);
    if (fs.existsSync(envFile)) {
      const envConfig = require('dotenv').parse(fs.readFileSync(envFile));
      Object.keys(envConfig).forEach(key => {
        process.env[key] = envConfig[key];
      });
    }
    
    // Create Prisma client
    const prisma = new PrismaClient();
    
    // Test connection
    console.log(`Testing database connection for ${environment} environment...`);
    await prisma.$connect();
    console.log('âœ… Database connection successful');
    
    // Disconnect
    await prisma.$disconnect();
    return true;
  } catch (error) {
    console.error('âŒ Database connection failed:', error.message);
    return false;
  }
}

// Function to switch environment
async function switchEnvironment(environment) {
  if (!ENVIRONMENTS.includes(environment)) {
    console.error(`âŒ Invalid environment: ${environment}`);
    console.log(`Valid environments are: ${ENVIRONMENTS.join(', ')}`);
    return false;
  }
  
  // Check if environment file exists
  if (!checkEnvFile(environment)) {
    console.error(`âŒ Environment file .env.${environment} does not exist`);
    return false;
  }
  
  // Test database connection
  const dbConnected = await testDatabaseConnection(environment);
  if (!dbConnected) {
    const proceed = await prompt('Database connection failed. Do you want to proceed anyway? (y/n): ');
    if (proceed.toLowerCase() !== 'y') {
      return false;
    }
  }
  
  // Update .env file to point to the selected environment
  const envContent = `# This file is auto-generated by switch-environment.js
# It points to the current active environment: ${environment}
NODE_ENV=${environment}
`;
  
  fs.writeFileSync(path.join(ROOT_DIR, '.env'), envContent);
  console.log(`âœ… Switched to ${environment} environment`);
  
  // Additional environment-specific setup
  if (environment === 'development') {
    // For development, ensure local database is set up
    try {
      console.log('Setting up local development database...');
      execSync('node scripts/setup-local-db.js', { stdio: 'inherit', cwd: ROOT_DIR });
    } catch (error) {
      console.error('âŒ Failed to set up local database:', error.message);
    }
  }
  
  return true;
}

// Function to display current environment
function showCurrentEnvironment() {
  try {
    // Try to determine from .env file
    const envPath = path.join(ROOT_DIR, '.env');
    if (fs.existsSync(envPath)) {
      const envContent = fs.readFileSync(envPath, 'utf8');
      const match = envContent.match(/NODE_ENV=(\w+)/);
      if (match && match[1]) {
        console.log(`Current environment: ${match[1]}`);
        return match[1];
      }
    }
    
    // Fallback to NODE_ENV
    const nodeEnv = process.env.NODE_ENV || 'development';
    console.log(`Current environment: ${nodeEnv} (from NODE_ENV)`);
    return nodeEnv;
  } catch (error) {
    console.error('âŒ Failed to determine current environment:', error.message);
    return null;
  }
}

// Main function
async function main() {
  console.log('ðŸŒ RRDM Environment Switcher');
  console.log('============================');
  
  // Show current environment
  const currentEnv = showCurrentEnvironment();
  
  // Show available environments
  console.log('\nAvailable environments:');
  for (const env of ENVIRONMENTS) {
    const exists = checkEnvFile(env);
    console.log(`${env === currentEnv ? 'âž¡ï¸' : ' '} ${env}${exists ? '' : ' (missing .env file)'}`);
  }
  
  // Prompt for environment
  const selectedEnv = await prompt('\nSelect environment (or press Enter to keep current): ');
  
  // If no environment selected, exit
  if (!selectedEnv) {
    console.log('No changes made. Exiting...');
    rl.close();
    return;
  }
  
  // Switch environment
  const success = await switchEnvironment(selectedEnv);
  
  if (success) {
    console.log('\nâœ… Environment switch completed');
    console.log(`To start the server in ${selectedEnv} environment, run:`);
    console.log('npm run dev');
  } else {
    console.log('\nâŒ Environment switch failed');
  }
  
  rl.close();
}

// Run main function
main().catch(error => {
  console.error('An unexpected error occurred:', error);
  rl.close();
  process.exit(1);
});
